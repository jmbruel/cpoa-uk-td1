= Design Patterns - TD 1
J.-M. Bruel <jbruel@gmail.com>
v20.1 {localdate}
:uk:
:imagesdir: images
//------------------------- variables de configuration
// only used when master document
:icons: font
:experimental:
:numbered!:
:status:
:baseURL: https://github.com/LP-APSIO/MobileModeling2020
:github: https://github.com[GitHub]
// Specific to GitHub
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]
//------------------------------------ 
ifdef::uk[]
:lastName: LAST NAME
:firstName: First Name
:group: Group
:example: Example
:Enseignants: Teachers
:principe: Principe Objet
endif::[]
ifndef::uk[]
:lastName: NOM
:firstName: Prénom
:group: Groupe
:example: Exemple
:Enseignants: Enseignants
:principe: Good design principle
endif::[]
//------------------------------------ 

TD1 initial code.
This is a template for the students' assignments.

//------------------------------------ 
== Assignment info

{lastName}:: BRUEL
{firstName}:: Jean-Michel

Group #::

[%interactive]
- [x] {Enseignants}
- [ ] 1
- [ ] 2
- [ ] 3
- [ ] 4
- [ ] Innopolis

//------------------------------------ 
== Requirements

You'll need:

[%interactive]
* [x] A {Github} account  
* [ ] A https://gitforwindows.org/[Git Bash] terminal (if you use Window$)

[TIP]
====    
Try the following command in your terminal to check your `git` environment:

[source,shell]
....
git config --global -l
....
====

//------------------------------------ 
== Initial tasks

[%interactive]
* [x] Click on the Github Classroom link provided by your teacher (in fact, this should be done if you read this).
* [ ] Clone on your machine the Github project generated by Github Classroom.  
* [ ] Modify the README file to add your last name, first name and group number. 
* [ ] Commit and push using the following message:

.pass:[<i class="fa fa-github"></i>] commit/push
[source,shell]
....
fix #0 Initial task done
....

[IMPORTANT]
ifndef::uk[]
Dans la suite de ce document, à chaque fois que vous trouverez un énoncé commençant par `fix #...` vous devez vérifier que vos scripts/fichiers modifiés sont bien dans votre dépôt local en vue de committer et de pusher les modifications sur votre dépôt distant en utilisant comme message de commit cet énoncé.
endif::[]
ifdef::uk[]
In the following, every time you'll see à `fix #...` text, 
make sure all your files are committed, and then push your modifications in the distant repo, making sure you used the corresponding message (`fix #...`) in one of the `commit` messages.
endif::[]

[TIP]
====
- If you want to check that you're really ready for `fix #0`, you can run the command in your shell: `make check`.
- If you want to list the ToDos of the day, run `make todos`.
====


:numbered:
//------------------------------------ 
== The "SuperCanard" application

[NOTE]
=====
This TD exercise is inspired from the excellent https://www.oreilly.com/library/view/head-first-design/0596007124/[book]: "Head First: Design Pattern.
Bert Bates, Eric Freeman, Elisabeth Freeman, Kathy Sierra. Editions O'Reilly. 2005."

image::headFirst.jpg[link="https://www.oreilly.com/library/view/head-first-design/0596007124/",width=40%]
=====

=== Existing application

You are asked to work on an existing app `SuperCanard` (duck, called _canard_ in French, simulation game) which model (sorry for the French) is provided in the following class diagram:

.Existing app model (plantUML source link:images/superCanard.plantuml[here])
image::superCanard.png[]

NOTE: Some other classes inherit from `Canard`.

Here is a code example:

.First version of `Canard.java`
[source,java]
--------
abstract public class Canard {

	public void cancaner() {
		System.out.println("Je cancane comme un Canard!");
	}

	public void nager() {
		System.out.println("Je nage comme un Canard!");
	}

	abstract public void afficher();
}
--------

.First version of `Colvert.java`
[source,java]
--------
public class Colvert extends Canard {

	public void afficher() {
		System.out.println("Je suis un Colvert");
	}

}
--------

To launch the tests on this code, try:

[source,shell]
----
mvn test
----

[NOTE]
====
The tests should fail, and your auto-grading, from your previous commit should not be full. 
Check your last commit on your repo:

.Access to your commit status
image::check.png[]

.Get details on failure
image::autograding.png[]
====


//----------------------------- Question ------------------
.*TODO*:
[WARNING]
====
[%interactive]
* [ ] Build the app using maven:
+
.pass:[<i class="fa fa-github"></i>] commit/push
[source,shell]
....
mvn install
....
+
* [ ] Fix the (made on purpose) bug in the tests to make them pass
* [ ] When everything is OK, push your code:
+
.pass:[<i class="fa fa-github"></i>] commit/push
[source,shell]
....
fix #1.1 First (running) draft of SuperCanard
....
+
- [ ] Check again your commit on your repo:
+
.Get details on success :-)
image::autogradingOK.png[width=80%]
====

IMPORTANT: Take some time to check how the tests are organized.

=== Modification/Improvement

Your boss requires that you upgrade the application
in order to be a little more realistic.

You decide to add a `voler()` method to all your ducks:

.New feature
image::superCanard2-note.png[]

.Second version of `Canard.java`
[source,java]
--------
abstract public class Canard {

	public void cancaner() {
		System.out.println("Je cancane comme un Canard!");
	}

	public void nager() {
		System.out.println("Je nage comme un Canard!");
	}

	abstract public void afficher();

	public void voler() {
		System.out.println("Je vole comme un Canard!");
	};
}
--------

=== #WTF!

You receive an emergency call from your boss: in the application some plastic ducks start to fly!!!
In addition, sick ducks, that shouldn't fly, do so!

TIP: You forgot that some kind of ducks do not fly!

//----------------------------- Question ------------------
.*QUESTION*
[WARNING]
====
Complete this sentence: *Inheritance* is great to do
............. but is more problematic in terms of .............
====


=== Solution 1: redefine the methods

The first solution that comes to your mind is simple: redefine the `voler()` method for the ducks who don't fly.

//----------------------------- Question ------------------
.*TODO*:
[WARNING]
====
[%interactive]
- [ ] Add a (failing) test that checks that a `CanardEnPlastique` does not fly.
- [ ] Make it pass by modifying the `CanardEnPlastique` class. 
- [ ] Push your code with 
+
.pass:[<i class="fa fa-github"></i>] commit/push
[source,shell]
....
fix #1.4 Fixing the non-flying ducks
....
====

//----------------------------- Question ------------------
.*QUESTION*
[WARNING]
====
In the following list, what are the problems that inheritance can raise to define the behavior of a `Canard`? (Possibly multiple good answers) :

[options=interactive]
- [ ] Code is duplicated (rewritten) between sub-classes.
- [ ] Behavior changes at run-time are complicated.
- [ ] We cannot have dancing ducks.
- [ ] It is hard to know all the ducks' behaviors
- [ ] Ducks cannot fly and sing at the same time.
- [ ] Modifications can modify unexpectedly other ducks' behavior.
====


=== Solution 2: use of interfaces

You know try the use of _interfaces_ to improve the code.

//----------------------------- Question ------------------
.*QUESTION*
[WARNING]
====
. On the following diagram, place the inheritance relations (java `extends`) and the implementation relations (java `implements`):
+
.Existing app model (plantUML source link:images/superCanardInterfaces.plantuml[here])
image::superCanardInterfaces.png[]
+
. What do you think of the final result ?
====

=== Solution 3: isolate what changes

You realize you're facing the kind of problem you had in the `MPA` module: *CHANGES*!

Let us then apply our first _good principle_:

[NOTE]
.{principe}
====
Identify aspects of your code that vary and separate
them from the ones that don't.
====

//----------------------------- Question ------------------
.*QUESTION*
[WARNING]
====
What are the two main things that vary in your code?
====

==== Implementing behaviors

Let's try to implement behavior differently so that they are separated from the rest of the code.
For that we will use another good principle:

[NOTE]
.{principe}
====
Program an interface, not an implementation.
====

//----------------------------- Question ------------------
.*QUESTION*
[WARNING]
====
Propose a design (class diagram only)
with the following classes and/or interfaces (you'll have to decide): `ComportementVol`,
`VolerAvecDesAiles`, `NePasVoler`.
====

==== Adding the new behaviors to the code

We have now to somehow link the behaviors to their corresponding ducks' class.

//----------------------------- Question ------------------
.*QUESTION*
[WARNING]
====
[%interactive]
- [ ] Add to the `Canard` class two attributes to reference their behaviors.
- [ ] Remove the useless methods.
- [ ] Replace them (provide the corresponding code) to make use of the new attributes.
- [ ] Modify the constructors of `Colvert` (for example) so that the attributes are initialized.
// from André 2016 :
- [ ] Add to `Colvert` the `setMalade()` and `setGueri()` methods that allow at run-time to modify the flying behavior.

.pass:[<i class="fa fa-github"></i>] commit/push
[source,shell]
....
fix #1.6 Implementing outside behavior
....

====

==== Summary and discussions

Let us now have a look at the overall design we have obtained.

//----------------------------- Question ------------------
.*QUESTION*
[WARNING]
====
[%interactive]
- [ ] Draw (or automatically obtain) the class diagram of the new application.
- What would you modify to add for example a new flying mode (e.g., _jet propulsion_) ?
- Could you think of a class that could use the `Cancan`
behavior without being a duck?
====

=== Your first _Design Pattern_

==== The *Strategy* pattern

In fact, you have just implemented your first _Design Pattern_ :
the _Strategy_ pattern (*Stratégie*), sorry for the French:

[[strategy]]
[NOTE]
.Design pattern: *Strategy*
====
include::pattern/strategy-uk.txt[]
====

.Some examples of descriptions of _Strategy_
image::google-strategy.png[link="images/google-strategy.png"]

==== Let's try it on another application

//----------------------------- Question ------------------
[WARNING]
====
You are asked to rework an application where only the following model was produced (sorry again for the damn French):

image::aventure-sujet.png[link="images/aventure-sujet.png"]

[%interactive]
- [ ] Reorganize the classes
- [ ] Identify abstract classes, interfaces and regular classes.
- [ ] Trace the links between classes ("is a", implementation, "has a")
- [ ] Place the following `setArme()` method on the
correct class:

.`setArme()` method 
[source,java]
-----
setArme(ComportementArme a) {
  this.arme = a;
}
-----

.pass:[<i class="fa fa-github"></i>] commit/push
[source,shell]
....
fix #1.7 Adventure game
....
====







//------------------------------------ 
== Contributors
//------------------------------------ 

- mailto:jbruel@gmail.com[Jean-Michel Bruel]
